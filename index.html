<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>TP4 WebVR - A-Frame 0.9.2</title>
    <script src="https://aframe.io/releases/0.9.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@3.3.0/dist/aframe-physics-system.min.js"></script>
    <!-- Optionnel : particules compatibles https://unpkg.com/aframe-particle-system-component@1.0.9/dist/aframe-particle-system-component.min.js -->
    <script src="https://unpkg.com/super-hands@3.0.3/dist/super-hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/wmurphyrd/aframe-extras@4.1.2/dist/aframe-extras.min.js"></script>
  </head>
  <body>
    <a-scene physics="gravity: -9.8" shadow="type: pcfsoft">
      <!-- Sol -->
      <a-plane position="0 0 0" rotation="-90 0 0" width="50" height="50"
               color="#7BC8A4" static-body shadow="receive: true"></a-plane>
      <!-- Cube 3D -->
      <a-box position="-1 0.5 -3" depth="1" height="1" width="1" color="#4CC3D9"
             dynamic-body grabbable shadow="cast: true; receive: true"></a-box>
      <!-- Sphère 3D -->
      <a-sphere position="2 1 -3" radius="0.7" color="#EF2D5E"
                dynamic-body grabbable shadow="cast: true; receive: true"></a-sphere>
      <!-- Lumière directionnelle avec ombres -->
      <a-entity light="type: directional; intensity: 0.8; castShadow: true"
                position="0 4 2"></a-entity>
      <!-- Lumière ambiante -->
      <a-entity light="type: ambient; color: #BBB"></a-entity>
      <script>
        // Utilitaires
        function readStickAxes(axis){
          // Certains profils/émulateurs envoient les sticks sur [2,3]
          const ax = axis || [];
          let x = ax[0] ?? 0, y = ax[1] ?? 0;
          if (Math.abs(x) < 0.001 && Math.abs(y) < 0.001 && ax.length >= 4) {
            x = ax[2] ?? 0; y = ax[3] ?? 0;
          }
          return {x, y};
        }
        function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

        // Joystick gauche = déplacement (g/d inversé corrigé)
        AFRAME.registerComponent('left-stick-move', {
          schema: { speed: {type:'number', default:3}, deadzone:{type:'number', default:0.05} },
          init() {
            this.axis = {x:0,y:0};
            this.rig  = document.querySelector('#rig');
            this.cam  = document.querySelector('#head');
            this.el.addEventListener('axismove', e => { this.axis = readStickAxes(e.detail.axis); });
          },
          tick(t,dt){
            if(!this.rig||!this.cam) return;
            const s = this.data.speed(dt/1000);
            let {x,y} = this.axis;
            if (Math.hypot(x,y) < this.data.deadzone) return;

            const yaw=(this.rig.getAttribute('rotation')?.y||0)+(this.cam.getAttribute('rotation')?.y||0);
            const rad=THREE.MathUtils.degToRad(yaw);
            const forward=new THREE.Vector3(-Math.sin(rad),0,-Math.cos(rad));
            const right  =new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0)).negate();

            this.rig.object3D.position
              .addScaledVector(forward, -ys)  // avancer/reculer (inverse si tu préfères)
              .addScaledVector(right,   -x*s); // gauche/droite (inversé corrigé)
          }
        }); 
      // Joystick droit = yaw (VR+desktop) + pitch (desktop seulement)
        AFRAME.registerComponent('right-stick-turn', {
          schema:{ turnSpeed:{type:'number',default:120}, deadzone:{type:'number',default:0.08} },
          init(){
            this.x=0; this.y=0;
            this.rig  = document.querySelector('#rig');
            this.head = document.querySelector('#head');
            this.el.addEventListener('axismove', e => {
              const a = readStickAxes(e.detail.axis);
              this.x = a.x; this.y = a.y;
            });
          },
          tick(t,dt){
            if(!this.rig) return;
            const s = this.data.turnSpeed * (dt/1000);

            // Yaw (gauche/droite) – sens inversé demandé
            let x=this.x;
            if (Math.abs(x) >= this.data.deadzone) {
              const rot=this.rig.getAttribute('rotation')||{x:0,y:0,z:0};
              rot.y -= Math.sign(x)*Math.pow(Math.abs(x),1.3) * s; // -x = sens inversé
              this.rig.setAttribute('rotation', rot);
            }

            // Pitch (haut/bas) UNIQUEMENT hors VR (en VR: c'est le HMD)
            const isXR = this.el.sceneEl?.renderer?.xr?.isPresenting;
            if (!isXR && this.head) {
              let y=this.y;
              if (Math.abs(y) >= this.data.deadzone) {
                const hr=this.head.getAttribute('rotation')||{x:0,y:0,z:0};
                hr.x = clamp(hr.x + (-y*s), -80, 80); // -y = mapping naturel
                this.head.setAttribute('rotation', hr);
              }
            }
          }
        });
      </script>
      <a-entity teleport-controls="enabled: false"></a-entity>
      <!-- Rig caméra + contrôleurs (Exercice 1) -->
      <a-entity id="rig">
        <a-entity camera look-controls position="0 1.6 4"></a-entity>
        <a-entity hand-controls="hand: left" left-stick-move></a-entity>
        <a-entity hand-controls="hand: right" right-stick-turn></a-entity>
      </a-entity>
    </a-scene>
  </body>
</html>
